List.of(A Type) = tags.
    case(.New)
    case(.Cons($.current(A) next(List.of(A))))

(this Int).+(that Int) = ffi.javascript("k$this + k$that").as(Int)

{A Type} {B Type}
(this List.of(A)).map(f Function.in(A) out(B)) | List.of(B) =
    this.
        case(.New):
            (List.New)
        case(.Cons(c)):
            (List.Cons(c.current(x | f.apply(x)).next(.map(f))))
        

= List.Cons($.current(1) next(List.Cons($.current(2) next(List.New))))
    .map(.+(2))
    .map(.+(3))