="list declartion";
a:type.list | type 
    =   (_.tag nil)
    .or (_.tag cons carry (record.current a next (a.list)));

{a:type} 
x:a.cons xs:(a.list) | a.list = cons.carry(record.current x next xs);

{a:type}
xs:(a.list).++ ys:(a.list) | a.list =
    xs.
        nil?  ys
        cons? (xs.current.cons(xs.next.++ys));

{a:type}
xs:(a.list).sum | int = 
    xs.foldl(x y | x.+y) startingwith 0;

{a:type b:type}
xs:(a.list).map f:(a.to b) | b.list = 
    xs.
        nil?  nil
        cons? (f.apply(xs.current).cons(xs.next.map f));

{a:type}
xs:(a.list).filter f:(a.to boolean) | a.list =
    xs.
        nil? nil
        cons? 
            (f.apply(xs.current).
                true?  (xs.current.cons(xs.next.filter f))
                false? (nil.cons(xs.next.filter f)));


{a:type b:type}
xs:(a.list).foldl f:(b.pair a.to b) startingWith value:b | b =
    xs.
        nil?  value
        cons? (xs.next.foldl f startingWith(f.apply(xs.current)));
    