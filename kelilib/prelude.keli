Boolean = tags.
    #(true) 
    #(false) 

(this Boolean).or(that Boolean) = 
    this.
        if(true):
            (Boolean.true)
        if(false):
            (that)

(this Boolean).and(that Boolean) = 
    this.
        if(true):
            (that)
        if(false):
            (Boolean.false)

(this Boolean).not = 
    this.
        if(true):
            (Boolean.false)
        if(false):
            (Boolean.true)


(x Int).-(y Int)  = ffi.javascript("$x - $y").as(Int)
(x Int).+(y Int)  = ffi.javascript("$x + $y").as(Int)
(x Int).*(y Int)  = ffi.javascript("$x * $y").as(Int)
(x Int).^(y Int) =  ffi.javascript("Math.pow($x, $y)").as(Int)
(x Int).>(y Int)  = ffi.javascript("$x > $y   ? $Boolean.$true : $Boolean.$false").as(Boolean)
(x Int).<(y Int)  = ffi.javascript("$x < $y   ? $Boolean.$true : $Boolean.$false").as(Boolean)
(x Int).>=(y Int) = ffi.javascript("$x >= $y  ? $Boolean.$true : $Boolean.$false").as(Boolean)
(x Int).<=(y Int) = ffi.javascript("$x <= $y  ? $Boolean.$true : $Boolean.$false").as(Boolean)
(x Int).==(y Int) = ffi.javascript("$x === $y ? $Boolean.$true : $Boolean.$false").as(Boolean)


(x Float).-(y Float)  = ffi.javascript("$x - $y").as(Float)
(x Float).+(y Float)  = ffi.javascript("$x + $y").as(Float)
(x Float).*(y Float)  = ffi.javascript("$x * $y").as(Float)
(x Float).^(y Float) =  ffi.javascript("Math.pow($x, $y)").as(Float)
(x Float).>(y Float)  = ffi.javascript("$x > $y   ? $Boolean.$true : $Boolean.$false").as(Boolean)
(x Float).<(y Float)  = ffi.javascript("$x < $y   ? $Boolean.$true : $Boolean.$false").as(Boolean)
(x Float).>=(y Float) = ffi.javascript("$x >= $y  ? $Boolean.$true : $Boolean.$false").as(Boolean)
(x Float).<=(y Float) = ffi.javascript("$x <= $y  ? $Boolean.$true : $Boolean.$false").as(Boolean)
(x Float).==(y Float) = ffi.javascript("$x === $y ? $Boolean.$true : $Boolean.$false").as(Boolean)

(x Int).toFloat = ffi.javascript("Math.trunc($x)").as(Float)
(x Float).toInt = ffi.javascript("$x").as(Int)

{A Type}
(x A).toString = ffi.javascript("$x.toString()").as(String)

(this String).++(that String) = ffi.javascript("$this + $that").as(String)

Result.ok(A Type) fail(B Type) = tags.
    #(ok.value(A))
    #(fail.with(B))

{A Type} {B Type} {C Type}
(this Result.ok(A) fail(B)).then(f Function.in(A) out(C))
    | Result.ok(C) fail(B)
    = this.
        if(ok.value(v)):
            (Result.ok.value(f.apply(v)))
        if(fail.with(error)):
            (Result.fail.with(error))

List.of(A Type) = tags.
    #(nil)
    #(cons.current(A) next(List.of(A)))

{A Type}
(this List.of(A)).length 
    | Int 
    = this.
        if(nil):
            (0)
        if(cons.next(n)):
            (1.+(n.length))

{A Type}
(this List.of(A)).add(element A) 
    | List.of(A)
    = this.
        if(nil):
            (List.cons.current(element) next(List.nil))
        if(cons.current(c) next(n)):
            (List.cons.current(c) next(n.add(element)))

{A Type}
(this List.of(A)).filter(f Function.in(A) out(Boolean))
    | List.of(A)
    = this.
        if(nil):
            (List.nil)
        if(cons.current(c) next(n)):
            (f.apply(c).
                if(true):
                    (List.cons.current(c) next(n.filter(f)))
                if(false):
                    (n.filter(f)))

{A Type} {B Type}
(this List.of(A)).map(f Function.in(A) out(B))
    | List.of(B)
    = this.
        if(nil):
            (List.nil)
        if(cons.current(c) next(n)):
            (List.cons.current(f.apply(this)) next(n.map(f)))

{A Type} {B Type}
(this List.of(A)).
    select(f Function.in(A) out(B))
    where(g Function.in(A) out(Boolean))
    | List.of(B)
    = this.
        if(nil):
            (List.nil)
        if(cons.current(c) next(n)):
            (g.apply(c).
                if(true):
                    (List.cons.
                        current(f.apply(c)) 
                        next(n.select(f) where(g)))
                if(false):
                    (n.select(f) where(g)))


{A Type}
(this List.of(A))._show
    | String
    = this.
        if(nil):
            ("")
        if(cons.current(c) next(n)):
            (c.toString.++(",").++(n._show))

{A Type}
(this List.of(A)).show
    | String
    = "[".++(this._show).++("]")