Boolean = tags.
    case(true) 
    case(false) 

(this Boolean).or(that Boolean) = 
    this.
        case(true):
            (Boolean.true)
        case(false):
            (that)

(this Boolean).and(that Boolean) = 
    this.
        case(true):
            (that)
        case(false):
            (Boolean.false)

(this Boolean).not = 
    this.
        case(true):
            (Boolean.false)
        case(false):
            (Boolean.true)


"minus"
(x Int).-(y Int)  = ffi.javascript("k$x - k$y").as(Int)

"plus"
(x Int).+(y Int)  = ffi.javascript("k$x + k$y").as(Int)

"multiply"
(x Int).*(y Int)  = ffi.javascript("k$x * k$y").as(Int)

"integral divide, the decimal point would be truncated"
(x Int)./(y Int)  = ffi.javascript("Math.trunc(k$x / k$y)").as(Int)

"power"
(x Int).^(y Int) =  ffi.javascript("Math.pow(k$x, k$y)").as(Int)

"more than"
(x Int).>(y Int)  = ffi.javascript("k$x > k$y   ? k$Boolean.true : k$Boolean.false").as(Boolean)

"less than"
(x Int).<(y Int)  = ffi.javascript("k$x < k$y   ? k$Boolean.true : k$Boolean.false").as(Boolean)

"more than or equals to"
(x Int).>=(y Int) = ffi.javascript("k$x >= k$y  ? k$Boolean.true : k$Boolean.false").as(Boolean)

"less than or equals to"
(x Int).<=(y Int) = ffi.javascript("k$x <= k$y  ? k$Boolean.true : k$Boolean.false").as(Boolean)

"equals"
(x Int).==(y Int) = ffi.javascript("k$x === k$y ? k$Boolean.true : k$Boolean.false").as(Boolean)

"negate a number"
(x Int).- = ffi.javascript("(-k$x)").as(Int)


(x Float).-(y Float)  = ffi.javascript("k$x - k$y").as(Float)
(x Float).+(y Float)  = ffi.javascript("k$x + k$y").as(Float)
(x Float).*(y Float)  = ffi.javascript("k$x * k$y").as(Float)
(x Float).^(y Float) =  ffi.javascript("Math.pow(k$x, k$y)").as(Float)
(x Float).^(y Int) =  ffi.javascript("Math.pow(k$x, k$y)").as(Float)
(x Float).>(y Float)  = ffi.javascript("k$x > k$y   ? k$Boolean.true : k$Boolean.false").as(Boolean)
(x Float).<(y Float)  = ffi.javascript("k$x < k$y   ? k$Boolean.true : k$Boolean.false").as(Boolean)
(x Float).>=(y Float) = ffi.javascript("k$x >= k$y  ? k$Boolean.true : k$Boolean.false").as(Boolean)
(x Float).<=(y Float) = ffi.javascript("k$x <= k$y  ? k$Boolean.true : k$Boolean.false").as(Boolean)
(x Float).==(y Float) = ffi.javascript("k$x === k$y ? k$Boolean.true : k$Boolean.false").as(Boolean)
(x Float).sqrt = ffi.javascript("Math.sqrt(k$x)").as(Float)

(x Int).toFloat = ffi.javascript("Math.trunc(k$x)").as(Float)
(x Float).toInt = ffi.javascript("k$x").as(Int)

{A Type}
(x A).toString = ffi.javascript("KELI_PRELUDE$show(k$x)").as(String)

{A Type}
(x A).equals(y A) = ffi.javascript("k$x === k$y ? k$Boolean.true : k$Boolean.false").as(Boolean)


(this String).==(that String) = ffi.javascript("k$this === k$that ? k$Boolean.true : k$Boolean.false").as(Boolean)
(this String).++(that String) = ffi.javascript("k$this + k$that").as(String)
(this String).replace(old String) with(new String) =
    ffi.javascript("k$this.replace(new RegExp(k$old, 'g'), k$new)").as(String)

Box.of(A Type) = tags.
    case(with.value(A))
    case(empty)

Result.ok(A Type) fail(B Type) = tags.
    case(ok.value(A))
    case(fail.with(B))

{A Type} {B Type} {C Type}
(this Result.ok(A) fail(B)).then(f Function.in(A) out(C))
    | Result.ok(C) fail(B)
    = this.
        case(ok.value(v)):
            (Result.ok.value(f.apply(v)))
        case(fail.with(error)):
            (Result.fail.with(error))

List.of(A Type) = tags.
    case(nil)
    case(cons.current(A) next(List.of(A)))

"The number of elements in this list"
{A Type}
(this List.of(A)).length 
    | Int 
    = this.
        case(nil):
            (0)
        case(cons.next(n)):
            (1.+(n.length))

{A Type}
(this List.of(A)).append(element A) 
    | List.of(A)
    = this.
        case(nil):
            (List.cons.current(element) next(List.nil))
        case(cons.current(c) next(n)):
            (List.cons.current(c) next(n.append(element)))


{A Type}
(this List.of(A)).filter(f Function.in(A) out(Boolean))
    | List.of(A)
    = this.
        case(nil):
            (List.nil)
        case(cons.current(c) next(n)):
            (f.apply(c).
                case(true):
                    (List.cons.current(c) next(n.filter(f)))
                case(false):
                    (n.filter(f)))
{A Type} {B Type}
(this List.of(A)).map(f Function.in(A) out(B))
    | List.of(B)
    = this.
        case(nil):
            (List.nil)
        case(cons.current(c) next(n)):
            (List.cons.current(f.apply(c)) next(n.map(f)))

{A Type} {B Type}
(this List.of(A)).
    select(f Function.in(A) out(B))
    where(g Function.in(A) out(Boolean))
    | List.of(B)
    = this.
        case(nil):
            (List.nil)
        case(cons.current(c) next(n)):
            (g.apply(c).
                case(true):
                    (List.cons.
                        current(f.apply(c)) 
                        next(n.select(f) where(g)))
                case(false):
                    (n.select(f) where(g)))

"To check if some element of a List fulfils the given predicate"
{A Type}
(this List.of(A)).some(predicate Function.in(A) out(Boolean))
    | Boolean
    = this.
        case(nil):
            (Boolean.false)
        case(cons.current(c) next(n)):
            (predicate.apply(c).
                case(true):
                    (Boolean.true)
                case(false):
                    (n.some(predicate)))

"To check if every element of a List fulfils the given predicate"
{A Type}
(this List.of(A)).every(predicate Function.in(A) out(Boolean))
    | Boolean
    = this.
        case(nil):
            (Boolean.true)
        case(cons.current(c) next(n)):
            (predicate.apply(c).
                case(true):
                    (n.every(predicate))
                case(false):
                    (Boolean.false))

{A Type}
(this List.of(A))._show
    | String
    = this.
        case(nil):
            ("")
        case(cons.current(c) next(n)):
            (c.toString.++(",").++(n._show))

{A Type}
(this List.of(A)).show
    | String
    = "[".++(this._show).++("]")

"Concat two list together."
{A Type}
(this List.of(A)).concat(that List.of(A))
    | List.of(A)
    = this.
        case(nil):
            (that)
        case(cons.current(c) next(n)):
            (List.cons.current(c) next(n.concat(that)))

"Reverse a list."
{A Type}
(this List.of(A)).reverse 
    | List.of(A)
    = this.
        case(nil):
            (List.nil)
        case(cons.current(c) next(n)):
            (n.reverse.concat(List.cons.current(c) next(List.nil)))

"Lookup an element."
{A Type}
(this List.of(A)).contains(value A)
    | Boolean
    = this.
        case(nil):
            (Boolean.false)
        case(cons.current(c) next(n)):
            (c.equals(value).
                case(true):
                    (Boolean.true)
                case(false):
                    (n.contains(value)))



"Get the first element of a list"
{A Type}
(this List.of(A)).head
    | Box.of(A)
    = this.
        case(nil):
            (Box.empty)
        case(cons.current(c) next(n)):
            (Box.with.value(c))

"Get the last element of a list"
{A Type}
(this List.of(A)).last
    | Box.of(A)
    = this.
        case(nil):
            (Box.empty)
        case(cons.current(c) next(n)):
            (n.
                case(nil):
                    (Box.with.value(c))
                default:
                    (n.last))

"Get all elements of this List, except the first element."
{A Type}
(this List.of(A)).tail
    | List.of(A)
    = this.
        case(nil):
            (List.nil)
        case(cons.current(c) next(n)):
            (n)

= List.nil.append(1).append(2).append(3).tail.show


"Get a range of integers"
(start Int).to(end Int) 
    | List.of(Int)
    = end.<(start).
        case(true):
            (end._forwardTo(start).reverse)
        case(false):
            (start._forwardTo(end))

(start Int)._forwardTo(end Int)
    | List.of(Int)
    = end.<(start).
        case(true):
            (List.nil)
        case(false):
            (List.cons.current(start) next(start.+(1)._forwardTo(end)))

= 99.to(87).show

= 0.to(10).show

= 10.to(10).show

= 0.to(10).some(.>(5))

= 0.to(2).every(.<(1))

= 0.to(10)

{A Type}
(this List.of(A))._at(index Int) currentIndex(value Int)
    | Box.of(A)
    = this.
        case(nil):
            (Box.empty)
        case(cons.current(c) next(n)):
            (index.equals(value).
                case(true):
                    (Box.with.value(c))
                case(false):
                    (n._at(index) currentIndex(value.+(1))))

"Retrieve a value at a speccaseied zero-based index."
{A Type}
(this List.of(A)).at(index Int)
    | Box.of(A)
    = this._at(index) currentIndex(0)

"Drop the specified number of elements from the front of a List."
{A Type}
(this List.of(A)).drop(x Int)
    | List.of(A)
    = x.<(1).
        case(true):
            (this)
        case(false):
            ((this.
                case(nil):
                    (List.nil)
                case(cons.current(c) next(n)):
                    (n.drop(x.-(1)))))

"Take the specified number of elements from the front of a List."
{A Type}
(this List.of(A)).take(x Int)
    | List.of(A)
    = this.reverse.drop(this.length.-(x)).reverse



= 0.to(10).drop(4).show

= 0.to(10).take(5).show

"Take elements from index a until inlcuding index b from a List."
{A Type}
(this List.of(A)).from(a Int) to(b Int)
    | List.of(A)
    = this.drop(a).take(b.-(a).+(1))

= 100.to(200).from(0) to(10).show

People = record.name(String) age(Int)

people = List.nil
    .append(People.name("Wong") age(21))
    .append(People.name("Lee") age(12))
    .append(People.name("koko") age(99))
    .append(People.name("jojo") age(20).name("haha"))


= people.select(.name) where(.age.>(20)).show

= people.select(.age) where(_ | Boolean.true).show



Shape = tags.
    case(circle.radius(Float))
    case(square.side(Float))
    case(rectangle.width(Float) height(Float))

"Calculate the area of a shape"
(this Shape).area =
    this.
        case(circle.radius(r)):
            (3.14.*(r.^(2)))
        case(square.side(s)):
            (s.^(2))
        case(rectangle.width(w) height(h)):
            (w.*(h))

= Shape.circle.radius(12.0)

= List.nil.append("12").append("!23").map(x | x.++("@")).show

Dict.key(K Type) value(V Type) = tags.
    case(nodes.
        key(K)
        value(V)
        left(Dict.key(K) value(V))
        right(Dict.key(K) value(V)))
    case(leaf)

// {K Type} {V Type} 
// (this Dict.key(K) value(V)).lookup(key K)
//     | Box.of(V)
//     = this.
//         case(nodes.key(k) value(v) left(l) right(r)):
//             (key.==(k).
//                 case(true):
//                     (Box.with.value(v))
//                 case(false):
//                     (l.lookup(k)))
//         case(leaf):
//             (Box.empty)

// {K Type} {V Type}
// (this Dict.key(K) value(V)).at(key K) put(value V)
//     | Dict.key(K) value(V)
//     = this.

// = Dict.nil
//     .at("ah ming") put("012345678")
//     .at("john") put("0123456")
//     .at("yo") put("hi")

(this Int).factorial | Int =
    this.<=(0).
        case(true):
            (1)
        case(false):
            (this.*(this.-(1).factorial))

= 300.<=(123).
    case(true):
        ("hello")
    case(false):
        ("bye")

= "Hello world".++(" and say goodbye")

= "Hello world".replace("Hello") with("bye")


// Definition
(n Int).fibonacci 
    | Int 
    = n.==(0).or(n.==(1)).
        case(true):  
            (n)
        case(false):
            (n.-(1).fibonacci.+(n.-(2).fibonacci))

// Usage
= 999.-.-.-.-.-.-.-.-.-.-

(this Int).! = this.factorial

Point = record.x(Float) y(Float)

(p1 Point).distanceTo(p2 Point) = 
    p1.x.-(p2.x).^(2).+(p1.y.-(p2.y).^(2)).sqrt

= Point.x(0.0) y(0.0).distanceTo(Point.x(3.0) y(4.0))


= 12.!

= List.nil.append(3).append(4).append(5).append(6).map(.^(2).+(2)).show

= Shape.circle.radius(12.0).area

{A Type}
(this List.of(A)).partitionBy(f Function.in(A) out(Boolean))
    | record.included(List.of(A)) excluded(List.of(A))
    = this._partitionBy(f) startingWith(record.included(List.nil) excluded(List.nil))

{A Type}
(this List.of(A)).
    _partitionBy(f Function.in(A) out(Boolean))
    startingWith(previousResult record.included(List.of(A)) excluded(List.of(A)))
    | record.included(List.of(A)) excluded(List.of(A))
    = this.
        case(nil):
            (previousResult)
        case(cons.current(c) next(n)):
            (f.apply(c).
                case(true):
                    (n._partitionBy(f) startingWith(previousResult.included(.append(c))))
                case(false):
                    (n._partitionBy(f) startingWith(previousResult.excluded(.append(c)))))

xs = List.nil.append(1).append(2).append(3).append(4)

= xs.last

result= xs.partitionBy(.>(2))

= result.included.show
= result.excluded.show

(this Int).div(that Int)
    | Result.ok(Int) fail(String)
    = that.==(0).
        case(true):
            (Result.fail.with("Division by zero"))
        case(false):
            (Result.ok.value(this./(that)))

= 123.div(2).then(.div(2))

ComparisonResult = tags.
    case(leftLessThanRight)
    case(leftEqualsRight)
    case(leftMoreThanRight)

(this Int).compare(that Int) =
    this.==(that).
        case(true):
            (ComparisonResult.leftEqualsRight)
        case(false):
            (this.>(that).
                case(true):
                    (ComparisonResult.leftMoreThanRight)
                case(false):
                    (ComparisonResult.leftLessThanRight))
